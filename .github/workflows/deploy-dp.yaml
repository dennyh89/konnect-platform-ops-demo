name: Deploy Kong Data Plane

on:
  workflow_call:
    inputs:
      environment:
        description: 'Environment to deploy to'
        type: string
        default: 'local'
      namespace:
        description: 'Kubernetes namespace'
        type: string
        default: 'kong'
      kong_image_repo:
        description: 'Kong image repository'
        default: 'kong/kong-gateway'
        type: string
      kong_image_tag:
        description: 'Kong image tag'
        default: '3.7.0.0'
        type: string
      control_plane_name:
        description: 'The name of the control plane to deploy the data plane to'
        type: string
        required: true
      system_account:
        description: 'The system account to use for authenticating with the Konnect API'
        type: string
        required: true
      action:
        description: 'Action to perform'
        required: true
        type: string
        default: 'deploy' # 'deploy' or 'destroy'

jobs: 
  prepare:
    runs-on: ubuntu-latest

    env:
      ENV_FILE: .github/env/${{ inputs.environment }}.yaml
      NAMESPACE: ${{ inputs.namespace }}
      KUBECONFIG: /.kube/config

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Load environment configuration
        uses: ./.github/actions/load-config
        with:
          environment: ${{ inputs.environment }}

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'latest'

      - name: Set up kubectl
        uses: azure/setup-kubectl@v4
        with:
          version: 'latest'

      - name: Import Secrets
        if: ${{ inputs.action == 'deploy' }}
        id: import-secrets
        uses: hashicorp/vault-action@v2
        with:
          url: ${{ env.VAULT_ADDR }}
          token: ${{ env.VAULT_TOKEN }}
          secrets: |
            konnect/data/certificates/common tls_key | TLS_KEY;
            konnect/data/certificates/${{ inputs.control_plane_name }} tls_crt | TLS_CERT;
            konnect/data/system_accounts/${{ inputs.system_account }} token | SYSTEM_ACCOUNT_TOKEN ;

      - name: Fetch control plane ${{ inputs.control_plane_name }} information
        if: ${{ inputs.action == 'deploy' }}
        run: |

          # Make the request and capture the response code and body
          response=$(curl -Gs -d "filter[name][eq]=${{ inputs.control_plane_name }}" -w "%{http_code}" "${{ env.KONNECT_SERVER_URL }}/v2/control-planes" -H "Authorization: Bearer ${{ steps.import-secrets.outputs.SYSTEM_ACCOUNT_TOKEN }}" -H "Content-Type: application/json")
          http_code=${response: -3}
          response_body=${response:0:-3}

          # Check the response code
          if [ "$http_code" -ne 200 ]; then
            echo "Request failed with status code $http_code"
            echo "Response body: $response_body"
            exit 1
          fi

          echo "Request succeeded with status code $http_code"
          echo "$response_body" | jq -c .data[0] > kong_gateway_control_plane_info.json

      - name: kubectl use context
        run: |
          kubectl config use-context ${{ secrets.KUBE_CONTEXT }}

      - name: Add Kong Helm Repository
        if: ${{ inputs.action == 'deploy' }}
        run: |
          helm repo add kong https://charts.konghq.com
          helm repo update
          
      - name: Create Kong namespace if not exists
        if: ${{ inputs.action == 'deploy' }}
        run: |
          kubectl create namespace $NAMESPACE --dry-run=client -o yaml | kubectl apply -f -
      
      - name: Create kong-cluster-cert secret if not exists
        if: ${{ inputs.action == 'deploy' }}
        run: |

          echo "$TLS_CERT" > tls.crt
          echo "$TLS_KEY" > tls.key

          kubectl create secret tls kong-cluster-cert \
              -n $NAMESPACE \
              --dry-run=client \
              --cert=tls.crt --key=tls.key -o yaml \
              | kubectl apply -f -

        env:
          TLS_CERT: ${{ steps.import-secrets.outputs.TLS_CERT }}
          TLS_KEY: ${{ steps.import-secrets.outputs.TLS_KEY }}

      - name: Deploy Kong Data Plane
        if: ${{ inputs.action == 'deploy' }}
        run: |

          CONTROL_PLANE_ENDPOINT=$(cat ./kong_gateway_control_plane_info.json | jq -r .config.control_plane_endpoint | sed 's|https://||')
          TELEMETRY_ENDPOINT=$(cat ./kong_gateway_control_plane_info.json | jq -r .config.telemetry_endpoint | sed 's|https://||')
          CONTROL_PLANE_NAME=$(echo ${{ inputs.control_plane_name }} | sed 's/_/-/g')

          # Validate all required inputs are set
          if [ "$CONTROL_PLANE_ENDPOINT" = "null" ] || [ "$TELEMETRY_ENDPOINT" = "null" ]; then
            echo "Missing required input(s)"
            echo "Control Plane Endpoint: $CONTROL_PLANE_ENDPOINT"
            echo "Telemetry Endpoint: $TELEMETRY_ENDPOINT"
            exit 1
          fi

          # Config exporter node
          # This node is responsible for exporting the configuration received from the control plane to an s3 bucket.
          # This configuration is then used by the data plane nodes to configure themselves if they cannot reach the control plane.
          # helm upgrade --install kong-config-exporter-$CONTROL_PLANE_NAME kong/kong \
          #   -n $NAMESPACE \
          #   --values  ${{ github.workspace }}/k8s/kong-dp/values.yaml \
          #   --set env.cluster_control_plane=$CONTROL_PLANE_ENDPOINT:443 \
          #   --set env.cluster_server_name=$CONTROL_PLANE_ENDPOINT \
          #   --set env.cluster_telemetry_endpoint=$TELEMETRY_ENDPOINT:443 \
          #   --set env.cluster_telemetry_server_name=$TELEMETRY_ENDPOINT \
          #   --set env.cluster_cert=/etc/secrets/kong-cluster-cert/tls.crt \
          #   --set env.cluster_cert_key=/etc/secrets/kong-cluster-cert/tls.key \
          #   --set proxy.enabled=false \
          #   --set customEnv.aws_region="main" \
          #   --set customEnv.aws_access_key_id=${{ secrets.S3_ACCESS_KEY }} \
          #   --set customEnv.aws_secret_access_key=${{ secrets.S3_SECRET_KEY }} \
          #   --set customEnv.aws_config_storage_endpoint="http://s3.minio.local:9000" \
          #   --set env.cluster_fallback_config_storage=s3://konnect/default/fallbackconfig \
          #   --set env.cluster_fallback_config_export="on"

          helm upgrade --install kong-dp-$CONTROL_PLANE_NAME kong/kong \
            -n $NAMESPACE \
            --values  ${{ github.workspace }}/k8s/kong-dp/values.yaml \
            --set replicaCount="1" \
            --set env.cluster_control_plane=$CONTROL_PLANE_ENDPOINT:443 \
            --set env.cluster_server_name=$CONTROL_PLANE_ENDPOINT \
            --set env.cluster_telemetry_endpoint=$TELEMETRY_ENDPOINT:443 \
            --set env.cluster_telemetry_server_name=$TELEMETRY_ENDPOINT \
            --set env.cluster_cert=/etc/secrets/kong-cluster-cert/tls.crt \
            --set env.cluster_cert_key=/etc/secrets/kong-cluster-cert/tls.key \
            --set customEnv.aws_region="main" \
            --set customEnv.aws_access_key_id=${{ secrets.S3_ACCESS_KEY }} \
            --set customEnv.aws_secret_access_key=${{ secrets.S3_SECRET_KEY }} \
            --set customEnv.aws_config_storage_endpoint="http://s3.minio.local:9000" \
            --set env.cluster_fallback_config_storage=s3://konnect/default/fallbackconfig \
            --set env.cluster_fallback_config_import="on"

      - name: Destroy Kong Deployment
        if: ${{ inputs.action == 'destroy' }}
        run: |
            CONTROL_PLANE_NAME=$(echo ${{ inputs.control_plane_name }} | sed 's/_/-/g')
            if helm status kong-dp-$CONTROL_PLANE_NAME -n $NAMESPACE >/dev/null 2>&1; then
              helm uninstall kong-dp-$CONTROL_PLANE_NAME -n $NAMESPACE
              helm uninstall kong-config-exporter-$CONTROL_PLANE_NAME -n $NAMESPACE
            fi